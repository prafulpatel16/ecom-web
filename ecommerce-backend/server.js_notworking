const express = require('express');
const { Pool } = require('pg');
const cors = require('cors');
require('dotenv').config();
const amqplib = require('amqplib');

const app = express();

// Configure PostgreSQL connection
const pool = new Pool({
  user: process.env.POSTGRES_USER,
  host: process.env.POSTGRES_HOST,
  database: process.env.POSTGRES_DB,
  password: process.env.POSTGRES_PASSWORD,
  port: process.env.POSTGRES_PORT,
});

// Enable CORS
app.use(cors({
  origin: '*',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
}));

// Middleware to parse JSON bodies
app.use(express.json());

// Root route handler
app.get('/api', (req, res) => {
  res.send('Welcome to the backend server. Please use the /products endpoint to retrieve data.');
});

// Get products endpoint
app.get('/api/products', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM products');
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching products:', err);
    res.status(500).send('Server error');
  }
});

// RabbitMQ configuration
const rabbitmqUrl = process.env.RABBITMQ_URL || 'amqp://guest:guest@rabbitmq:5672';
let channel;

const connectRabbitMQ = async () => {
  try {
    const connection = await amqplib.connect(rabbitmqUrl, {
      credentials: amqplib.credentials.plain(
        process.env.RABBITMQ_DEFAULT_USER || 'guest',
        process.env.RABBITMQ_DEFAULT_PASS || 'guest'
      )
    });
    channel = await connection.createChannel();
    console.log('Connected to RabbitMQ');
  } catch (err) {
    console.error('Failed to connect to RabbitMQ:', err);
    throw err;
  }
};

const sendToQueue = async (queue, message) => {
  try {
    if (!channel) {
      throw new Error('Channel not initialized');
    }
    await channel.deleteQueue('product_queue');
    await channel.assertQueue(queue, { durable: true }); // Set TTL to 10 minutes
    channel.sendToQueue(queue, Buffer.from(message));
    console.log(`Message sent to queue: ${queue}`);
  } catch (err) {
    console.error('Failed to send message to queue:', err);
    throw err;
  }
};

const consumeFromQueue = async (queue, callback) => {
  try {
    if (!channel) {
      throw new Error('Channel not initialized');
    }
    await channel.deleteQueue('product_queue');
    await channel.assertQueue(queue, { durable: true });
    channel.consume(queue, (msg) => {
      if (msg !== null) {
        const message = msg.content.toString();
        console.log(`Message received from queue: ${queue}`);
        if (typeof callback === 'function') {
          callback(message);
        } else {
          console.error('Callback is not a function');
        }
        channel.ack(msg);
      }
    });
  } catch (err) {
    console.error('Failed to consume message from queue:', err);
    throw err;
  }
};

// Connect to RabbitMQ and start consuming messages
connectRabbitMQ().then(() => {
  consumeFromQueue('product_queue', async (message) => {
    try {
      const product = JSON.parse(message);
      // Process the product data (e.g., save to database)
      console.log('Message processed:', product);
    } catch (error) {
      console.error('Error processing message:', error);
    }
  });
});

const port = process.env.PORT || 5000;

app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});